# Particle Simulation 게임

이 프로젝트는 Raylib을 사용한 입자(Particle) 시뮬레이션 게임으로, 플레이어가 파티클을 조작하고 적을 물리치는 인터랙티브 시뮬레이션입니다.

## 게임 개요

이 게임은 물리 기반 파티클 시뮬레이션을 통해 유체와 중력의 개념을 시각적으로 표현합니다. 플레이어는 작은 빨간색 사각형을 조작하여 수많은 파티클들을 끌어당기고, 이를 이용해 주기적으로 나타나는 적들을 물리칠 수 있습니다. 게임의 목표는 최대한 많은 적을 파괴하고 높은 점수를 달성하는 것입니다.

## 상세 기능

### 플레이어 (Player)
- **비주얼**: 작은 빨간색 사각형으로 화면에 표시됩니다.
- **이동**: WASD 키 또는 방향키를 사용하여 상하좌우로 이동할 수 있습니다.
- **파티클 끌어당기기**: 플레이어 주변의 파티클들을 자동으로 끌어당깁니다.
- **강화된 인력**: 스페이스바를 누르고 있으면 파티클을 끌어당기는 힘이 2배로 증가합니다.
- **위치 교체**: 특수 키를 누르면 플레이어가 랜덤 파티클과 위치를 교체하여 빠르게 이동할 수 있습니다.
- **충돌 감지**: 적들과 충돌할 경우 게임 오버 조건을 트리거합니다.

### 파티클 (Particle)
- **총 개수**: 최대 100,000개의 파티클이 시뮬레이션에 포함됩니다.
- **비주얼**: 작은 검은색 점으로 표시되며, 속도에 따라 색상이 약간 변화합니다.
- **물리 특성**: 
  - 질량, 위치, 속도 및 가속도 정보를 가집니다.
  - 플레이어로부터의 거리에 반비례하는 인력을 받습니다.
  - 마찰력에 의해 서서히 속도가 감소합니다.
- **상호작용**: 
  - 플레이어와 상호작용하여 끌려옵니다.
  - 적과 충돌하여 적의 체력을 감소시킵니다.

### 적 (Enemy)
- **생성 주기**: 평균 3초마다 화면 내 랜덤 위치에 생성됩니다.
- **비주얼**: 
  - 보라색 원형으로 표시됩니다.
  - 플레이어 크기의 3-10배 크기를 가집니다.
  - 체력이 감소할수록 색상이 단계적으로 변화합니다 (보라색 → 빨간색 → 노란색).
  - 체력에 따라 투명도가 변화합니다 (체력이 낮을수록 더 투명해짐).
- **체력 시스템**: 
  - 초기 체력은 크기에 비례합니다.
  - 파티클과 충돌할 때마다 일정 체력이 감소합니다.
  - 체력이 0이 되면 폭발 효과와 함께 제거됩니다.
- **행동 패턴**: 
  - 기본적으로 플레이어 방향으로 천천히 이동합니다.
  - 일정 확률로 방향을 변경하여 무작위적인 움직임을 보입니다.

### 점수 시스템
- **점수 획득**: 
  - 적 처치 시 적의 크기에 비례하는 점수를 획득합니다.
  - 더 큰 적을 처치할수록 더 많은 점수를 얻습니다.
- **기록 저장**: 
  - 게임 종료 시 점수가 자동으로 `scoreboard.txt` 파일에 기록됩니다.
  - 상위 10개의 최고 점수가 저장되고 표시됩니다.
- **점수 표시**: 게임 화면 상단에 현재 점수와 최고 점수를 실시간으로 표시합니다.

### 특수 효과
- **폭발 효과**: 적이 파괴될 때 화려한 폭발 파티클 효과가 발생합니다.
- **시각적 피드백**: 파티클 끌어당기기, 적 피해, 점수 획득 등에 대한 시각적 피드백을 제공합니다.
- **화면 흔들림**: 적 처치 시 화면에 약간의 흔들림 효과가 발생하여 타격감을 높입니다.

### 이벤트 시스템 (Event System)
- **이벤트 기반 아키텍처**: 
  - 게임 내 모든 상호작용이 이벤트를 통해 처리되는 구조로 리팩토링 중입니다.
  - 코드의 결합도를 낮추고 확장성을 높이기 위한 설계를 적용했습니다.
  - 각 시스템 간의 직접적인 의존성을 제거하여 모듈화된 개발이 가능합니다.
- **주요 이벤트 타입**:
  - 시스템 이벤트: 프레임 시작/종료, 게임 초기화/종료 등 게임 루프 관련 이벤트
  - 입력 이벤트: 키보드 입력 감지 및 처리를 위한 이벤트 (KEY_PRESSED, KEY_RELEASED)
  - 충돌 이벤트: 엔티티 간 충돌 감지 및 처리를 위한 이벤트
  - 상태 변경 이벤트: 게임 상태 변화, 적 상태 변화 등을 알리는 이벤트
  - 파티클 이벤트: 파티클 이동, 소멸 등과 관련된 이벤트
  - 점수 관련 이벤트: 점수 변경, 최고 점수 달성 등의 이벤트
- **발행-구독 모델**:
  - 이벤트 발행자(Publisher)와 구독자(Subscriber) 간의 느슨한 결합
  - PublishEvent() 함수를 통해 이벤트를 발행하고, SubscribeToEvent() 함수로 이벤트 구독
  - 여러 시스템이 동일한 이벤트에 각각 다른 방식으로 반응 가능
  - 새로운 기능 추가 시 기존 코드 수정 없이 이벤트 구독만으로 확장 가능
- **이벤트 큐 시스템**:
  - 이벤트를 큐에 저장하고 ProcessEventQueue() 함수를 통해 순차적으로 처리
  - 동시에 발생하는 다수의 이벤트를 안정적으로 관리
  - 타임스탬프를 통한 이벤트 발생 시간 추적 및 디버깅 지원
- **이벤트 데이터 구조**:
  - KeyEventData: 키보드 입력 관련 데이터(키 코드, 누름/뗌 상태)
  - CollisionEventData: 충돌한 엔티티 정보 및 충돌 강도
  - EnemyDefeatedEventData: 처치된 적의 정보 및 점수
  - PlayerDamageEventData: 플레이어 피해 정보
  - GameStateChangeEventData: 게임 상태 변경 정보
  - 기타 게임 메카닉에 필요한 이벤트 데이터 구조체
- **메모리 관리**:
  - 이벤트 데이터의 동적 할당 및 자동 해제 메커니즘
  - 이벤트 처리 후 CleanupEventData 핸들러를 통한 메모리 정리
  - 메모리 누수 방지를 위한 안전한 설계
- **동적 이벤트 핸들링**:
  - 런타임에 이벤트 핸들러 등록 및 해제 가능
  - 컨텍스트 포인터를 통한 상태 공유 및 접근
  - 다양한 게임 상황에 따른 조건부 이벤트 처리

## 게임 조작법

- **W, A, S, D 키**: 플레이어를 상, 좌, 하, 우로 이동
- **방향키**: 플레이어 이동(WASD와 동일 기능)
- **스페이스바**: 누르고 있는 동안 파티클을 끌어당기는 힘이 증가(2배)
- **Q 키**: 플레이어가 랜덤 파티클과 위치 교체(텔레포트 효과)
- **R 키**: 게임 재시작
- **ESC 키**: 게임 종료

## 기술적 구현 상세

### 물리 시스템
- **중력 시뮬레이션**: 
  - 뉴턴의 중력 법칙을 단순화하여 구현했습니다 (F = G * m1 * m2 / r^2).
  - 거리가 너무 가까워지면 발산을 방지하기 위한 최소 거리 제한을 적용했습니다.
- **마찰력**: 
  - 각 파티클에 속도에 비례하는 마찰력을 적용하여 자연스러운 감속을 구현했습니다.
  - 마찰 계수는 게임 밸런스를 위해 세심하게 조정되었습니다.
- **충돌 감지 및 응답**: 
  - 파티클-적 충돌은 원형 충돌 감지(CheckCollisionCircles)를 사용합니다.
  - 충돌 시 파티클의 운동량이 적에게 전달되는 효과를 구현했습니다.

### 이벤트 시스템 구현 상세
- **핵심 컴포넌트**:
  - **EventSystem**: 이벤트 발행, 구독, 처리를 관리하는 핵심 모듈
  - **EventQueue**: 이벤트를 저장하고 순차적으로 처리하는 큐 구현
  - **EventHandler**: 이벤트 처리 함수 포인터 및 콜백 메커니즘
- **데이터 구조**:
  - **Event**: 이벤트 타입, 데이터, 타임스탬프를 포함하는 구조체
  - **EventType**: 다양한 이벤트 유형을 정의하는 열거형
  - **EventListener**: 이벤트 구독자 정보를 저장하는 구조체
- **주요 기능**:
  - **PublishEvent()**: 이벤트를 발행하고 큐에 추가
  - **SubscribeToEvent()**: 특정 이벤트 유형에 핸들러 등록
  - **ProcessEventQueue()**: 큐에 있는 모든 이벤트를 처리
  - **UnsubscribeFromEvent()**: 이벤트 구독 취소
- **메모리 관리**:
  - 이벤트 데이터를 위한 동적 할당 및 자동 해제 메커니즘
  - 이벤트 처리 후 메모리 정리를 담당하는 정리 핸들러

### 최적화 기술
- **공간 분할**: 충돌 감지 최적화를 위해 그리드 기반 공간 분할 기법을 적용했습니다.
- **벡터 연산**: SIMD 명령어를 활용하여 파티클 연산을 최적화했습니다.
- **병렬 처리**: 가능한 경우 OpenMP를 사용하여 파티클 업데이트를 병렬로 처리합니다.
- **메모리 관리**: 
  - 파티클 메모리 풀을 사용하여 동적 할당 오버헤드를 최소화했습니다.
  - 적 개체는 연결 리스트로 관리하여 효율적인 추가/제거가 가능합니다.

### 렌더링 시스템
- **Raylib 렌더링**: 
  - Raylib의 기본 도형 렌더링 함수를 사용하여 게임 요소를 그립니다.
  - 투명도, 색상 변화 등의 시각적 효과를 Raylib의 Color 처리 기능으로 구현했습니다.
- **최적화된 배치 렌더링**: 
  - 대량의 파티클을 효율적으로 렌더링하기 위해 배치 처리 기법을 적용했습니다.
  - 화면 밖 객체는 렌더링하지 않는 컬링 기법을 사용합니다.

## 코드 구조 및 모듈 설명

프로젝트는 다음과 같은 구조로 조직되어 있으며, 각 모듈은 특정 기능을 담당합니다:

```
├── src/
│   ├── main.c              # 메인 진입점, 게임 루프 관리
│   ├── core/
│   │   ├── game.c          # 게임 상태 관리 및 전체 게임 로직 조정
│   │   ├── game.h          # 게임 구조체 및 핵심 함수 선언
│   │   ├── physics.c       # 물리 시뮬레이션 기능 구현
│   │   ├── physics.h       # 물리 시뮬레이션 함수 선언
│   │   ├── input_handler.c # 입력 처리 및 이벤트 발행 
│   │   ├── input_handler.h # 입력 핸들러 함수 선언
│   │   └── event/          # 이벤트 시스템 관련 파일
│   │       ├── event_system.c  # 이벤트 시스템 핵심 기능 구현
│   │       ├── event_system.h  # 이벤트 시스템 인터페이스 정의
│   │       └── event_types.h   # 이벤트 데이터 구조체 정의
│   └── entities/
│       ├── player.c        # 플레이어 로직 및 상호작용 구현
│       ├── player.h        # 플레이어 구조체 및 함수 선언
│       ├── enemy.c         # 적 생성, 업데이트, 제거 로직
│       ├── enemy.h         # 적 구조체 및 관련 함수 선언
│       ├── particle.c      # 파티클 시뮬레이션 물리 및 행동 구현
│       ├── particle.h      # 파티클 구조체 및 관련 함수 선언
│       ├── explosion.c     # 폭발 효과 관련 기능 구현
│       ├── explosion.h     # 폭발 효과 구조체 및 함수 선언
│       └── managers/       # 엔티티 관리자 모듈
│           ├── enemy_manager.c    # 적 엔티티 관리 기능
│           ├── enemy_manager.h    # 적 관리자 인터페이스
│           ├── particle_manager.c # 파티클 엔티티 관리 기능
│           └── particle_manager.h # 파티클 관리자 인터페이스
├── bin/                    # 빌드된 실행 파일 저장 디렉토리
├── assets/                 # 게임 리소스 파일(예: 이미지, 사운드) 디렉토리
├── Makefile                # 빌드 설정 및 명령어 정의
├── scoreboard.txt          # 최고 점수 기록 저장 파일
└── README.md               # 프로젝트 설명 문서
```

### 모듈별 주요 기능

#### main.c
메인 진입점으로, 게임 초기화, 메인 루프, 종료 처리를 담당합니다.
- **InitGame()**: Raylib 및 게임 요소 초기화
- **UpdateGame()**: 프레임마다 게임 상태 업데이트
- **DrawGame()**: 현재 게임 상태 렌더링
- **CloseGame()**: 게임 종료 및 리소스 해제

#### game.c/h
게임의 전체 상태를 관리하고 다른 모듈 간의 상호작용을 조정합니다.
- **Game 구조체**: 게임의 모든 상태를 포함하는 중앙 데이터 구조
- **InitGameState()**: 게임 상태 초기화
- **UpdateGameState()**: 모든 게임 객체 업데이트 및 충돌 검사
- **HandleCollisions()**: 게임 내 충돌 감지 및 처리
- **UpdateScore()**: 점수 계산 및 기록
- **SaveHighScore()**: 최고 점수 파일 저장

#### event_system.c/h
이벤트 기반 아키텍처의 핵심 구성 요소입니다.
- **이벤트 관리**: 이벤트 생성, 발행, 구독 및 처리
- **이벤트 큐**: 이벤트의 순차적 처리를 위한 큐 구현
- **핸들러 관리**: 이벤트 핸들러 등록 및 관리
- **메모리 관리**: 이벤트 데이터의 안전한 할당 및 해제

#### input_handler.c/h
키보드 입력 처리와 이벤트 발행을 담당합니다.
- **키 입력 감지**: 방향키, 액션키 등의 입력 감지
- **이벤트 발행**: 입력에 따른 적절한 이벤트 생성 및 발행
- **핸들러 등록**: 입력 이벤트를 처리할 핸들러 등록
- **메모리 관리**: 입력 이벤트 데이터의 동적 할당 및 해제

#### player.c/h
플레이어 캐릭터와 관련된 모든 기능을 구현합니다.
- **Player 구조체**: 플레이어 위치, 크기, 속도 등 정보
- **InitPlayer()**: 플레이어 초기화
- **UpdatePlayer()**: 입력 처리 및 플레이어 상태 업데이트
- **DrawPlayer()**: 플레이어 렌더링
- **HandlePlayerInput()**: 키보드 입력 처리
- **SwapWithParticle()**: 파티클과 위치 교체 구현

#### enemy.c/h
적 개체의 생성, 행동, 제거 등을 처리합니다.
- **Enemy 구조체**: 적의 위치, 크기, 체력, 상태 정보
- **CreateEnemy()**: 새로운 적 생성
- **UpdateEnemies()**: 모든 적 객체 상태 업데이트
- **DrawEnemies()**: 적 객체 렌더링
- **DamageEnemy()**: 적 피해 처리
- **DestroyEnemy()**: 적 제거 및 폭발 효과 생성

#### particle.c/h
파티클 시스템과, 물리 시뮬레이션을 구현합니다.
- **Particle 구조체**: 파티클의 위치, 속도, 질량 등 정보
- **InitParticles()**: 파티클 시스템 초기화
- **UpdateParticles()**: 모든 파티클 물리 업데이트
- **DrawParticles()**: 파티클 렌더링
- **ApplyForceToParticle()**: 파티클에 힘 적용
- **CreateParticleEffect()**: 특수 효과용 파티클 생성

## 빌드 및 실행 방법

### 요구 사항

- **운영체제**: macOS, Windows, Linux
- **라이브러리**: Raylib 5.5 이상
- **컴파일러**: GCC 9.0+ 또는 호환 가능한 컴파일러
- **빌드 도구**: Make

### 빌드 방법

```bash
# 프로젝트 빌드
make

# 프로젝트 실행
make run

# 빌드 파일 정리
make clean
```

### 의존성 설치 (macOS)

```bash
# Homebrew를 통한 Raylib 설치
brew install raylib

# 또는 소스에서 직접 빌드
git clone https://github.com/raysan5/raylib.git
cd raylib/src
make
sudo make install
```

## 개발 과정 및 Git 브랜치 관리

프로젝트는 다음과 같은 단계로 개발되었습니다:

1. **초기 개발 (main 브랜치)**:
   - 기본 프로젝트 구조 설정
   - Raylib 초기화 및 창 설정
   - 플레이어 및 기본 파티클 구현
   - 파티클 끌어당기기 물리 구현

2. **'warp' 브랜치**:
   - 플레이어와 파티클 위치 교체 기능 구현
   - Q 키를 눌러 랜덤 파티클과 위치 교체
   - 텔레포트 시각 효과 및 쿨다운 구현
   - 성능 최적화 및 버그 수정
   - main 브랜치에 병합 완료

3. **'enemy' 브랜치**:
   - Enemy 구조체 및 관련 함수 정의
   - 3초마다 랜덤 위치에 적 생성
   - 적-파티클 충돌 감지 및 피해 처리
   - 적 체력 시스템 및 시각적 변화 구현
   - 적 폭발 효과 구현
   - main 브랜치에 병합 완료

4. **점수 시스템 구현**:
   - 적 처치 시 점수 획득 로직
   - 점수 표시 및 최고 점수 저장
   - scoreboard.txt 파일 관리
   - main 브랜치에 직접 구현

5. **이벤트 시스템 구현**:
   - 이벤트 시스템 핵심 구조 설계 및 구현
   - 이벤트 발행-구독 메커니즘 구현
   - 이벤트 큐 및 핸들러 시스템 개발
   - 입력 처리를 이벤트 기반으로 리팩토링
   - 점진적 마이그레이션을 통한 안정성 확보
   - 메모리 누수 방지를 위한 자동 해제 메커니즘 구현

6. **최적화 및 정리**:
   - 코드 리팩토링 및 모듈화
   - 상수 정의 및 가독성 개선
   - 주석 추가 및 문서화
   - 메모리 누수 수정 및 성능 최적화

## GitHub 저장소

프로젝트 코드는 GitHub에서 확인할 수 있습니다: [https://github.com/NAMYUNWOO/particles](https://github.com/NAMYUNWOO/particles)

## 라이센스

이 프로젝트는 MIT 라이센스 하에 배포됩니다. 자세한 내용은 LICENSE 파일을 참조하세요.

## 향후 계획

- **이벤트 시스템 확장**:
  - 충돌 감지 시스템의 이벤트 기반 전환
  - 게임 상태 변경을 이벤트로 처리
  - 적 생성 및 파괴 과정을 이벤트 기반으로 구현
  - 시각/청각 효과를 위한 이벤트 시스템 통합

- **다양한 적 유형**: 다른 행동 패턴과 특성을 가진 적 추가
- **플레이어 능력치 시스템**: 게임 진행에 따라 강화되는 플레이어 능력
- **레벨 시스템**: 다양한 스테이지와 난이도 구현
- **특수 효과 강화**: 더 화려하고 다양한 파티클 효과
- **사운드 및 음악**: 게임 분위기를 높이는 효과음과 배경음악
- **멀티플레이어 모드**: 로컬 또는 네트워크 멀티플레이어 지원
- **커스터마이징 옵션**: 게임 설정 및 시각적 요소 사용자 정의